#include "global.h"
#include "texte.h"

#ifndef INLINE
# include "texte.ci"
#endif


static inline unsigned int texte_rechercher_newline(const char * str);


char * strcopy(const char * str) {
  //return strcpy(malloc(strlen(str) + 1), str);
  const int len = strlen(str);
  char * new_str = malloc(len + 1);
  strlcpy(new_str, str, len + 1);
  return new_str; 
}

char * substring(const char * str, unsigned int debut, unsigned int fin) {
  unsigned int len;
  unsigned int taille;
  char * retour;
  
  assert(debut <= fin);

  len = fin - debut;

  taille = (len + 1) * (sizeof (char));

  retour = (char *) malloc(taille);

  memcpy(retour, str + debut, taille);

  retour[len] = '\0';

  return retour;
}

char * strsub(const char * str, unsigned int debut, unsigned int len) {
  unsigned int str_len;
  unsigned int taille;
  char * retour;

  str_len = strlen(str);

  assert(str_len >= debut + len); 

  taille = (len + 1) * (sizeof (char));

  retour = (char *) malloc(taille);

  memcpy(retour, str + debut, taille);

  retour[len] = '\0';

  return retour;
}




static char * strconcat_malloc(const int dest_size) {
  assert(1 <= dest_size); 
  char * dest_str = NULL; 
  dest_str = malloc(dest_size); 
  //strlcpy(dest_str, "" dest_size); 
  *dest_str = '\0'; 
  return dest_str; 
}; 
 
char * strconcat(const char * str1, const char * str2) {
  register unsigned int len = strlen(str1) + strlen(str2);
  return strcat(strcat(strconcat_malloc(len+1), str1), str2);
}

char * strconcat3(const char * str1, const char * str2, const char * str3) {
  register unsigned int len = strlen(str1) + strlen(str2) + strlen(str3);
  return strcat(strcat(strcat(strconcat_malloc(len+1), str1), str2), str3);
}

char * strconcat4(const char * str1, const char * str2, const char * str3, const char * str4) {
  register unsigned int len = strlen(str1) + strlen(str2) + strlen(str3) + strlen(str4);
  return strcat(strcat(strcat(strcat(strconcat_malloc(len+1), str1), str2), str3), str4);
}

char * strconcat5(const char * str1, const char * str2, const char * str3, const char * str4, const char * str5) {
  register unsigned int len = strlen(str1) + strlen(str2) + strlen(str3) + strlen(str4) + strlen(str5);
  return strcat(strcat(strcat(strcat(strcat(strconcat_malloc(len+1), str1), str2), str3), str4), str5);
}

char * strconcat6(const char * str1, const char * str2, const char * str3, const char * str4, const char * str5, const char * str6) {
  register unsigned int len = strlen(str1) + strlen(str2) + strlen(str3) + strlen(str4) + strlen(str5) + strlen(str6);
  return strcat(strcat(strcat(strcat(strcat(strcat(strconcat_malloc(len+1), str1), str2), str3), str4), str5), str6);
}

char * strconcat7(const char * str1, const char * str2, const char * str3, const char * str4, const char * str5, const char * str6, const char * str7) {
  register unsigned int len = strlen(str1) + strlen(str2) + strlen(str3) + strlen(str4) + strlen(str5) + strlen(str6) + strlen(str7);
  return strcat(strcat(strcat(strcat(strcat(strcat(strcat(strconcat_malloc(len+1), str1), str2), str3), str4), str5), str6), str7);
}


char * strmap(int (* f)(int), const char * str) {
  char * retour;
  size_t i;
  size_t len;

  len = strlen(str);

  retour = (char *) malloc(len + 1);

  for (i = 0; i < len; i++) {
    retour[i] = ((char) (f(((int) (str[i])))));
  }

  retour[len] = '\0';

  return retour;
}


const char * chaine_of_bool(bool b) {
  return (b ? "VRAI" : "FAUX");
}

char * chaine_of_char(char c) {
  char * retour;

  retour = malloc(2 * sizeof(char));

  retour[0] = c;
  retour[1] = '\0';

  return retour;
}

char * chaine_of_integer(int n) {
  char * retour;

  asprintf(&retour, "%d", n);

  return retour;
}

char * chaine_of_real(double x) {
  char * retour;

  asprintf(&retour, "%f", x);

  return retour;
}

  


// Fonctions de conversion du format de caractere ANSI vers OEM et vice-versa.
// Utile car notre police est au format OEM.
//  message("Je crois avoir trouver ce sale bug dans oem2ansi ; test : (table_oem2ansi[-1]  (%c) == table_oem2ansi[128] (%c)) = %d (faux = %d)", table_oem2ansi[-1], table_oem2ansi[128], table_oem2ansi[-1] == table_oem2ansi[128], false);
// ====> Attention a la signature.
// Meme chose avec le 0x00 partout la-dedans... qui signifie fin de chaine !!!!!
// donc on met '?' (0x3F) a la place.
// de plus, conversion en (unsigned int) pas bon car -1 donne 4 milliards et qques, 
// au lieu de 255; donc conversion en (unsigned char)!!!

static const char table_ansi2oem[256] = {
  0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
  0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
  0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
  0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
  0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
  0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,
  0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
  0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x03F,0x0AD,0x09B,0x09C,0x03F,0x09D,0x03F,0x03F,0x03F,0x03F,0x03F,0x0AE,0x0AA,0x0A9,0x03F,0x03F,
  0x0F8,0x0F1,0x0FD,0x03F,0x03F,0x0E6,0x014,0x03F,0x03F,0x03F,0x0F8,0x0AF,0x0AC,0x0AB,0x03F,0x0A8,
  0x041,0x041,0x041,0x041,0x08E,0x08F,0x092,0x080,0x045,0x090,0x045,0x045,0x049,0x049,0x049,0x049,
  0x044,0x0A5,0x04F,0x04F,0x04F,0x04F,0x099,0x078,0x0ED,0x055,0x055,0x055,0x09A,0x059,0x03F,0x0E1,
  0x085,0x0A0,0x083,0x061,0x084,0x086,0x091,0x087,0x08A,0x082,0x088,0x089,0x08D,0x0A1,0x08C,0x08B,
  0x03F,0x0A4,0x095,0x0A2,0x093,0x06F,0x094,0x0F6,0x0ED,0x097,0x0A3,0x096,0x075,0x079,0x03F,0x098
};

static const char table_oem2ansi[256] = {
  0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
  0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
  0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
  0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x2F,
  0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
  0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,
  0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
  0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,
  0x0C7,0x0FC,0x0E9,0x0E2,0x0E4,0x0E0,0x0E5,0x0E7,0x0EA,0x0EB,0x0E8,0x0EF,0x0EE,0x0EC,0x0C4,0x0C5,
  0x0C9,0x0E6,0x0C6,0x0F4,0x0F6,0x0F2,0x0FB,0x0F9,0x0FF,0x0D6,0x0DC,0x0A2,0x0A3,0x0A5,0x09E,0x09F,
  0x0E1,0x0ED,0x0F3,0x0FA,0x0F1,0x0D1,0x03F,0x03F,0x0BF,0x0AD,0x0AC,0x0BD,0x0BC,0x0A1,0x0AB,0x0BB,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
  0x03F,0x0DF,0x03F,0x03F,0x03F,0x03F,0x0B5,0x03F,0x03F,0x03F,0x03F,0x03F,0x03F,0x0F8,0x03F,0x03F,
  0x03F,0x0B1,0x03F,0x03F,0x03F,0x03F,0x0F7,0x03F,0x0F8,0x03F,0x03F,0x03F,0x03F,0x0B2,0x03F,0x03F
};

// ansi2oem : chaine -> chaine
char * ansi2oem(register const char * str) {
  register const unsigned int taille = strlen(str);
  register char * const temp = (char *) malloc(taille + 1);
  unsigned int i;

  for (i = 0; i < taille; i++) {
    temp[i] = table_ansi2oem[(unsigned char) (str[i])];
  }

  temp[taille] = '\0';

  return temp;
}

// oem2ansi : chaine -> chaine
char * oem2ansi(register const char * str) {
  register const unsigned int taille = strlen(str);
  register char *const temp = (char *) malloc(taille + 1);
  unsigned int i;
  
  for (i = 0; i < taille; i++) {
    temp[i] = table_oem2ansi[(unsigned char) (str[i])];
  }

  temp[taille] = '\0';

  return temp;
}


void texte_en_ligne(const char * str, unsigned int * lignes_nombre, char * * * ligne_tableau) {
  unsigned int nb_lignes;
  unsigned int i;
  unsigned int l;
  char * temp;
  char * * tableau;

  nb_lignes = texte_lignes_nombre(str);

  tableau = (char * *) malloc(nb_lignes * (sizeof (*tableau)));

  for (i = 0; i < nb_lignes; i++) {
    l = texte_rechercher_newline(str);

    temp = (char *) malloc((l + 1) * sizeof(char));
    memcpy(temp, str, l * sizeof(char));
    temp[l] = '\0';

    tableau[i] = temp;

    // on avance: on skippe la ligne et le '\n'
    str += l + 1;
  }

  *lignes_nombre = nb_lignes;
  *ligne_tableau = tableau;
}

unsigned int texte_lignes_nombre(const char * str) {
  unsigned int len;
  unsigned int i;
  unsigned int nb;

  len = strlen(str);

  nb = 0;

  for (i = 0; i < len; i ++) {
    if (str[0] == '\n') nb ++;
  }

  return nb;
}

unsigned int texte_rechercher_newline(const char * str) {
  unsigned int i;
  char c;

#if 0
  while (not(*str) && (*str != LF)) str++;
#endif

  for (i = 0; ; i ++) {
    c = str[i];
    if (c == '\n' || c == '\0') return i;
  }

  assert(false);
  return -1;
}



